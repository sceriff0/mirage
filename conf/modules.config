/*
========================================================================================
    Process-specific Resource Configuration
========================================================================================
    Direct SLURM resource allocation for each process
========================================================================================
*/

process {

    /*
    ================================================================================
        Resource Labels (used by processes)
    ================================================================================
    */

    /*
    ================================================================================
        Default Publishing Settings
    ================================================================================
    */

    publishDir = [
        path: { "${params.outdir}/${task.process.tokenize(':')[-1].toLowerCase()}" },
        mode: 'copy',
        saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
    ]

    /*
    ================================================================================
        Resource Labels (used by processes)
    ================================================================================
    */

    withLabel: 'process_single' {
        cpus   = { check_max( 4                  , 'cpus'   ) }
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = { check_max( 8.h  * task.attempt, 'time'   ) }
        errorStrategy = { task.exitStatus in [1, 11, 137, 139, 140] ? 'retry' : 'finish' }
        maxRetries = 3
    }

    withLabel: 'process_low' {
        cpus   = { check_max( 2     * task.attempt, 'cpus'   ) }
        memory = { check_max( 12.GB * task.attempt, 'memory' ) }
        time   = { check_max( 4.h   * task.attempt, 'time'   ) }
        errorStrategy = { task.exitStatus in [1, 137, 139, 140] ? 'retry' : 'finish' }
        maxRetries = 3
    }

    withLabel: 'process_medium' {
        cpus   = { check_max( 8     * task.attempt, 'cpus'   ) }
        memory = { check_max( 200.GB * task.attempt, 'memory' ) }
        time   = { check_max( 8.h   * task.attempt, 'time'   ) }
        errorStrategy = { task.exitStatus in [1, 137, 139, 140] ? 'retry' : 'finish' }
        maxRetries = 3
    }

    withLabel: 'process_high' {
        cpus   = { check_max( 12    * task.attempt, 'cpus'   ) }
        memory = { check_max( 300.GB * task.attempt, 'memory' ) }
        time   = { check_max( 16.h  * task.attempt, 'time'   ) }
        errorStrategy = { task.exitStatus in [1, 137, 139, 140] ? 'retry' : 'finish' }
        maxRetries = 3
    }

    withLabel: 'process_long' {
        time   = { check_max( 48.h  * task.attempt, 'time'   ) }
    }

    withLabel: 'process_high_memory' {
        memory = { check_max( 400.GB * task.attempt, 'memory' ) }
    }

    withLabel: 'gpu' {
        clusterOptions = '--gres=gpu:1'
        containerOptions = '--nv'  // Enable NVIDIA GPU support in Singularity
    }

    withLabel: 'error_ignore' {
        errorStrategy = 'ignore'
    }

    withLabel: 'error_retry' {
        errorStrategy = 'retry'
        maxRetries    = 3
    }

    /*
    ================================================================================
        Pipeline Processes
    ================================================================================
    */

    withName: 'CONVERT_IMAGE' {
        ext.args = ''
        publishDir = [
            path: { "${params.outdir}/${meta.patient_id}/converted" },
            mode: 'copy',
            pattern: "*.{ome.tif,txt}"
        ]
    }

    withName: 'PREPROCESS' {
        ext.args = ''
        publishDir = [
            [
                path: { "${params.outdir}/${meta.patient_id}/preprocessed" },
                mode: 'copy',
                pattern: "*_corrected.ome.tif",
                overwrite: true
            ],
            [
                path: { "${params.outdir}/${meta.patient_id}/preprocessed/dims" },
                mode: 'copy',
                pattern: "*_dims.txt",
                enabled: false,
                overwrite: true
            ]
        ]
    }

    withName: 'GENERATE_PREPROCESS_QC' {
        publishDir = [
            path: { "${params.outdir}/${meta.patient_id}/qc/preprocess" },
            mode: 'copy',
            pattern: "qc/*.png"
        ]
    }

    withName: 'MAX_DIM' {
        cpus   = 1
        memory = '8.GB'
        time   = '10.m'
    }

    withName: 'REGISTER' {
        cpus   = 32
        memory = { check_max( 400.GB  + 100.GB * task.attempt, 'memory' ) }
        time   = { check_max( 48.h * task.attempt, 'time' ) }

        // Smart retry strategy:
        // - Exit 1: General failure (e.g., JVM killed, registration error) -> retry without micro-reg
        // - Exit 137: OOM (SIGKILL) -> retry with more memory AND without micro-reg
        // - Exit 134: SIGABRT -> retry
        // - Exit 104: Connection reset -> retry
        // On retry (attempt 2+), register.nf automatically skips micro-registration
        errorStrategy = { task.exitStatus in [1, 134, 137, 104, 140] ? 'retry' : 'finish' }
        maxRetries    = 3

        publishDir = [
            path: { "${params.outdir}/${patient_id}/registered" },
            mode: 'copy',
            pattern: "registered_slides/*_registered.ome.tiff",
            overwrite: true
        ]
    }
    withName: 'GPU_REGISTER' {
        // Dynamic resources defined in process (based on file size)
        // Memory: Small (<10GB) = 128GB, Medium (10-30GB) = 256GB, Large (>30GB) = 388GB
        // Time: Small = 2h, Medium = 3h, Large = 6h
        // CPU and GPU allocation handled in process definition

        publishDir = [
            path: { "${params.outdir}/${meta.patient_id}/registered" },
            mode: 'copy',
            pattern: "*_registered.ome.tiff",
            overwrite: true
        ]
    }

    withName: 'CPU_REGISTER' {
        cpus   = 64
        memory = { check_max( 128.GB * task.attempt, 'memory' ) }
        time   = { check_max( 8.h * task.attempt, 'time' ) }

        errorStrategy = { task.exitStatus in [137, 104] ? 'retry' : 'finish' }
        maxRetries    = 2

        publishDir = [
            path: { "${params.outdir}/${meta.patient_id}/registered" },
            mode: 'copy',
            pattern: "*_registered.ome.tiff",
            overwrite: true
        ]
    }

    /*
    ================================================================================
        CPU Tiled Registration Processes (memory-efficient two-pass approach)
    ================================================================================
    */

    withName: 'COMPUTE_TILE_PLAN' {
        cpus   = 1
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
        time   = { check_max( 10.min * task.attempt, 'time' ) }
    }

    withName: 'AFFINE_TILE' {
        cpus   = 4
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time   = { check_max( 20.min * task.attempt, 'time' ) }

        errorStrategy = { task.exitStatus in [137, 139, 140] ? 'retry' : 'finish' }
        maxRetries    = 2

        maxForks = 10
    }

    withName: 'STITCH_AFFINE' {
        cpus   = 4
        memory = { check_max( 64.GB * task.attempt, 'memory' ) }
        time   = { check_max( 1.h * task.attempt, 'time' ) }
    }

    withName: 'DIFFEO_TILE' {
        cpus   = 4
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }
        time   = { check_max( 20.min * task.attempt, 'time' ) }

        errorStrategy = { task.exitStatus in [137, 139, 140] ? 'retry' : 'finish' }
        maxRetries    = 2

        maxForks = 10
    }

    withName: 'STITCH_DIFFEO' {
        cpus   = 4
        memory = { check_max( 64.GB * task.attempt, 'memory' ) }
        time   = { check_max( 1.h * task.attempt, 'time' ) }

        publishDir = [
            path: { "${params.outdir}/${meta.patient_id}/registered" },
            mode: 'copy',
            pattern: "*_registered.ome.tiff",
            overwrite: true
        ]
    }

    withName: 'PUBLISH_REFERENCE_CPU_TILED' {
        cpus   = 1
        memory = '4.GB'
        time   = '10.min'
    }

    withName: 'GENERATE_REGISTRATION_QC' {
        publishDir = [
            [
                path: { "${params.outdir}/${meta.patient_id}/qc/registration" },
                mode: 'copy',
                pattern: "qc/*_QC_RGB.{png,tif}"
            ],
            [
                path: { "${params.outdir}/${meta.patient_id}/qc/registration" },
                mode: 'copy',
                pattern: "qc/*_QC_RGB_fullres.tif"
            ]
        ]
    }

    withName: 'MERGE_AND_PYRAMID' {
        cpus   = 4
        memory = '512.GB'
        time   = '8.h'
    }

    withName: 'SEGMENT' {
        cpus   = 4
        memory = { check_max( 128.GB * task.attempt, 'memory' ) }
        time   = '4.h'
        // Retry on OOM errors - n_tiles will double on each attempt
        errorStrategy = { task.exitStatus in [1, 137, 139, 140] ? 'retry' : 'finish' }
        maxRetries = 3
        // Automatically adds GPU based on params.seg_gpu
        clusterOptions = { params.seg_gpu ? '--gres=gpu:nvidia_h200:1' : '' }
    }

    withName: 'CLASSIFY' {
        cpus   = 4
        memory = '256.GB'
        time   = '3.h'
        // Automatically adds GPU based on params.classify_gpu
        clusterOptions = { params.classify_gpu ? '--gres=gpu:nvidia_h200:1' : '' }
    }

    withName: 'QUANTIFY' {
        cpus   = 8
        memory = '200.GB'
        time   = '12.h'
        // Automatically adds GPU based on params.quant_gpu
        //clusterOptions = { params.quant_gpu ? '--gres=gpu:nvidia_h200:1' : '' }
    }

    withName: 'PHENOTYPE' {
        cpus   = 4
        memory = { check_max( 64.GB * task.attempt, 'memory' ) }
        time   = '2.h'
        errorStrategy = { task.exitStatus == 137 ? 'retry' : 'finish' }
        maxRetries    = 2
    }

    withName: 'CREATE_PYRAMID' {
        cpus   = 4
        memory = '256.GB'
        time   = '4.h'
    }

    withName: 'COPY_RESULTS' {
        // File copying is I/O-bound, not CPU-bound
        // Consider running with executor='local' in profile if preferred
        cpus   = 1
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = '24.h'  // Allow long time for large dataset transfers

        errorStrategy = 'retry'
        maxRetries    = 2

        publishDir = [
            path: { "${params.outdir}/logs" },
            mode: 'copy',
            pattern: "rsync.log"
        ]
    }
}

